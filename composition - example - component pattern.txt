Component pattern
=================


root
	-- root of component
par
	-- parent
cpnt
	-- parts
rch		(auxiliary)
	-- reachability

always
	J4:		[ rch  â‰¡  +par ]

invariants
	J3:		root âˆˆ cpnt

	J1:		par âˆˆ cpnt â†” cpnt
			[ par  â‡’  cpnt ; true ; cpnt ]

	J0:		âŒ©âˆ€x: x âˆˆ cpnt: root(rch)xâŒª
			[ root ; true ; cpnt  â‡’  rch ]
				-- each component is reachable

	J2:		âŒ©âˆ€x,y:  x(+par)y âˆ§ y(rch)x: x = yâŒª
			[ rch âˆ§ ~rch  â‡’  J ]
				-- antisymmetric

	J5:		[ rch âˆ§ J  â‡’  false ]		
				-- acyclic

	J6:		âŒ©âˆ€x,y,z:: Â¬x(rch)z âˆ¨ Â¬y(rch)z âˆ¨ x(rch)y âˆ¨ y(rch)xâŒª
				-- disjoint
			[ rch ; ~rch  â‡’  rch âˆ¨ ~rch ]

theorem
	J7:		[ rch ; par  â‡’  rch ]
	J1 âˆ§ J0:  âŒ©âˆ€x:: x âˆˆ cpnt  â‰¡  root(rch)xâŒª

	add_new_child
		any c where
			{c} âˆ© cpnt = âŒ€
		do
		S0:	cpnt' = cpnt âˆª {c}
		end

invariance of J0 under add_new_child

			   x âˆˆ cpnt'
			=	{ S0 }
			   x âˆˆ cpnt  âˆ¨  x = c
			â‡’	{ J0 }
			   root'(rch)x âˆ¨ x = c

			   root'(rch')c
			â‡	{ J7 }
			   root'(rch' ; par')c
			â‡	{ witness }
			   root's(rch')p âˆ§ p(par')c
			=	{ S1: par' = par âˆª p â†” c }
			   root(rch')p
			=	{ J4 }
			   root(+par')p
			=	{ S1 }
			   root(+(par âˆª p â†” c))p
			=	{ + _ is monotonic }
			   root(rch)p
			=	{ J0 âˆ§ J1 }
			   p âˆˆ cpnt

	P0:		p âˆˆ cpnt
		with p a parameter

	S1:		par' = par âˆª p â†” c
